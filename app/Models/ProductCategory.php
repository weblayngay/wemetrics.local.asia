<?php

namespace App\Models;

use App\Models\Solutions\NestedSetModel;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use function PHPUnit\Framework\returnArgument;

class ProductCategory extends NestedSetModel
{
    use HasFactory;
    protected $table      = PRODUCT_CATEGORY_TBL;
    protected $primaryKey = 'pcat_id';
    const CREATED_AT = 'pcat_created_at';
    const UPDATED_AT = 'pcat_updated_at';

    protected $fillable = [
        'pcat_id',
        'pcat_name',
        'pcat_status',
        'parent',
        'level',
        'left',
        'right',
    ];


    /**
     * product category có 2 loại là Mỹ phẩm (cosmetic) và Giày dép (shoes)
     */
    const TYPE = [
        'cosmetic' => 3,
        'shoes' => 2,
    ];


    /**
     * Những node gốc này sẽ không được Xóa hay Cập nhật
     */
    const NODE_ROOT = [1, 2, 3];

    /**
     * @return Builder
     */
    static function parentQuery(): Builder
    {
        return parent::query();
    }


    /**
     * @return Builder
     */
    public static function query(): Builder
    {
        return parent::query(); // TODO: Change the autogenerated stub
    }


    /**
     * @param string $type
     * @return Builder[]|Collection
     */
    public function findByType(string $type = 'cosmetic')
    {
        $typeId = self::TYPE[$type] ?? self::TYPE['cosmetic'];
        $productCategory = static::parentQuery()->find($typeId);
        $left = 0;
        $right = 0;
        if ($productCategory) {
            $left = $productCategory->left;
            $right =  $productCategory->right;
        }

        return static::query()->where('left', '>', $left)->where('right', '<', $right)->orderBy('left', 'asc')->get();
    }


    /**
     * @param int $pcatId
     * @return Builder[]|Collection
     */
    public function getBranchs(int $pcatId)
    {
        $productCategory = $this::parentQuery()->select('*')->where('pcat_id', $pcatId)->first();
        $left = $right = 0;
        if ($productCategory) {
            $left = $productCategory->left;
            $right = $productCategory->right;
        }
        return $this::parentQuery()->select('*')
            ->orderBy('left', 'ASC')
            ->whereBetween('left', [$left, $right])
            ->where('level', '>', 0)
            ->where('right', '>', 0)
            ->get();
    }

    /**
     * @param array $params
     * @param string $positionNode
     * @return bool
     * @throws \Exception
     */
    public function createNode(array $params, string $positionNode = 'left'): bool
    {
        if ($params['parent'] == 1 && in_array($positionNode, ['after', 'before'])) {
            $positionNode = 'left';
        }
        return $this->insertNode($params, ['position' => $positionNode]);
    }


    /**
     * @param array $params
     * @param int $nodeMoveId
     * @param string $positionNode
     * @return bool
     * @throws \Exception
     */
    public function updateNode(array $params, int $nodeMoveId, string $positionNode = 'left'): bool
    {
        $item = $this::parentQuery()->find($nodeMoveId);

        $item->pcat_name   = $params['pcat_name'];
        $item->pcat_status = $params['pcat_status'];
        $item->save();


        // Thực hiện move node
        if ($params['parent'] == 1 && in_array($positionNode, array('after', 'before'))){
            return false;
        }elseif($params['parent'] != $item->pcat_id){
            $this->moveNode(['move_item' => $item, 'partner_id' => $params['parent']], ['position' => $positionNode]);
        }
        return true;
    }


    /**
     * @param array $params
     * @param string $type
     * @param int $partnerId
     * @return bool
     * @throws \Exception
     */
    public function deleteNode(array $params, int $partnerId, $type = 'only'): bool
    {
        $this->nodePartnerId = $partnerId;
        return $this->removeNode($params, ['type' => $type]);
    }
}
